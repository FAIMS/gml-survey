/***************************** TRANSECT GEOMETREY *****************************/
import java.util.concurrent.Semaphore;

addOnEvent("Transect/Transect/Start_Survey_Unit",  "click", "startSurveyUnit()");
addOnEvent("Transect/Transect/Finish_Survey_Unit", "click", "finishSurveyUnit()");
onFocus   ("Transect/Transect/Total_Transect_Width_m", "",  "populateSurveyExtent()");

INC_MUTEX = new Semaphore(1);

REF_EXTENT        = "Transect/Map/Survey_Extent_Square_Metres";
REF_UUID_STARTED  = "Transect/Vars/UUID_Started";
REF_UUID_FINISHED = "Transect/Vars/UUID_Finished";

REF_STATE = "Transect/Vars/Transect_State";

STATE_NONE     = "";
STATE_STARTED  = "STARTED";
STATE_FINISHED = "FINISHED";

startSurveyUnit() {
  if (!checkGps()) return;

  state = getState();
  if      (state.equals(STATE_NONE    )) tryIncrementingState();
  else if (state.equals(STATE_STARTED )) showToast("Survey already started");
  else if (state.equals(STATE_FINISHED)) showToast("Survey already finished");
}

finishSurveyUnit() {
  if (!checkGps()) return;

  state = getState();
  if      (state.equals(STATE_NONE    )) showToast("Survey not yet started");
  else if (state.equals(STATE_STARTED )) tryIncrementingState();
  else if (state.equals(STATE_FINISHED)) showToast("Survey already finished");
}

checkGps() {
  Object positionProj = getGPSPositionProjected();
  if (positionProj == null) {
    showToast("Unable to get GPS position");
    return false;
  }
  return true;
}

tryIncrementingState() {
  if (!INC_MUTEX.tryAcquire()) {
    showToast("Already taking a point...");
    return;
  }

  tabGroup               = "Transect";
  saveChildTransectPoint = "saveChildTransectPoint";

  // Already saved
  if (getUuid(tabGroup) != null) {
    uuid = getUuid(tabGroup);
    fetchIdentifier(uuid, saveChildTransectPoint);
    return;
  }

  // Not already saved. Save Transect immediately then enable autosaving.
  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      setUuid(tabGroup, uuid);

      // This should be equivalent to the autogenerated saveTabGroup call from
      // the onShowTransect function definition. This enables autosave after the
      // below saveTabGroup call is complete.
      saveTabGroup(tabGroup);

      fetchIdentifier(uuid, saveChildTransectPoint);
    }
  };
  saveTabGroup(tabGroup, null, null, null, saveCallback);
}

saveChildTransectPoint(String parentId) {
  parentTabGroup = "Transect";
  childTabGroup  = "Transect Point";

  Object positionProj = getGPSPositionProjected();
  String parentUuid   = getUuid(parentTabGroup);

  if (isNull(parentUuid)) {
    // Shouldn't happen because `tryIncrementingState` should've set parentUuid.
    Log.e("saveChildTransectPoint()", "Parent UUID is null");
    INC_MUTEX.release();
    return;
  }
  if (positionProj == null) {
    INC_MUTEX.release();
    return;
  }

  lat = positionProj.getLatitude();
  lon = positionProj.getLongitude();
  MapPos pos   = new MapPos(lat, lon);
  Point  point = new Point(pos, null, (PointStyle) null, null);
  List   geoList = new ArrayList(); geoList.add(point);

  String state = incState();
  if (state == null) {
    // Shouldn't ever happen
    Log.e("saveChildTransectPoint()", "Unexpected state");
    showWarning("Error", "A critial error has occurred. Point not saved.");
    INC_MUTEX.release();
    return;
  }

  String order;
  if (state.equals(STATE_STARTED )) order = "0";
  if (state.equals(STATE_FINISHED)) order = "1";

  List attribs = createAttributeList();
  attribs.add(createEntityAttribute("State",     null, null, state,    null));
  attribs.add(createEntityAttribute("Parent ID", null, null, parentId, null));
  attribs.add(createEntityAttribute("Order",     null, null, order,    null));

  saveCallback = new SaveCallback() {
    onSave(uuid, newRecord) {
      showToast("Survey " + state.toLowerCase());

      String rel = "%s - %s";
      rel = replaceFirst(rel, "%s", parentTabGroup);
      rel = replaceFirst(rel, "%s", childTabGroup);

      saveEntitiesToHierRel(rel, parentUuid, uuid, "Parent Of", "Child Of", "");

      if (state.equals(STATE_STARTED )) setFieldValue(REF_UUID_STARTED,  uuid);
      if (state.equals(STATE_FINISHED)) setFieldValue(REF_UUID_FINISHED, uuid);

      populateSurveyExtent();

      INC_MUTEX.release();
    }
  };
  saveArchEnt(null, childTabGroup, geoList, attribs, saveCallback);
}

populateSurveyExtent() {
  String refTransectWidth = "Transect/Transect/Total_Transect_Width_m";
  String sTransectWidth;

  sTransectWidth = getFieldValue(refTransectWidth);
  uuidStarted    = getFieldValue(REF_UUID_STARTED );
  uuidFinished   = getFieldValue(REF_UUID_FINISHED);

  if (isNull(sTransectWidth)) return;
  if (isNull(uuidStarted   )) return;
  if (isNull(uuidFinished  )) return;

  String q = "";
  q += " SELECT distance(startpoint, endpoint), astext(startpoint), astext(endpoint)";
  q += "   FROM (SELECT transform(geospatialcolumn, %s) AS startpoint";
  q += "           FROM latestnondeletedarchent";
  q += "          WHERE uuid = %s";
  q += "        ),";
  q += "        (SELECT transform(geospatialcolumn, %s) AS endpoint";
  q += "           FROM latestnondeletedarchent";
  q += "          WHERE uuid = %s";
  q += "        )";
  q  = replaceFirst(q, "%s", getModuleSrid());
  q  = replaceFirst(q, "%s", uuidStarted    );
  q  = replaceFirst(q, "%s", getModuleSrid());
  q  = replaceFirst(q, "%s", uuidFinished   );

  FetchCallback populate = new FetchCallback() {
    onFetch(result) {
      String sTransectLength = result.get(0);

      Double dTransectLength = Double.valueOf(sTransectLength);
      Double dTransectWidth  = Double.valueOf(sTransectWidth);
      Double dExtent         = dTransectLength * dTransectWidth;

      setFieldValue(REF_EXTENT, dExtent);
    }
  };

  fetchOne(q, populate);
}

fetchIdentifier(String uuid, String callback) {
  String q = "";
  q += "SELECT uuid, response ";
  q += "FROM latestnondeletedarchentformattedidentifiers ";
  q += "WHERE uuid = '%s' ";
  q  = replaceFirst(q, "%s", uuid);

  cb = new FetchCallback() {
    onFetch(result) {
      identifier  = result.get(1);

      callbackStr = "%s(\"%s\")";
      callbackStr = replaceFirst(callbackStr, "%s", callback);
      callbackStr = replaceFirst(callbackStr, "%s", identifier);
      execute(callbackStr);
    }
  };

  fetchOne(q, cb);
}

getState() {
  return getFieldValue(REF_STATE);
}

getNextState() {
  if (getState().equals(STATE_NONE   )) return STATE_STARTED;
  if (getState().equals(STATE_STARTED)) return STATE_FINISHED;
  return null;
}

setState(val) {
  setFieldValue(REF_STATE, val);
  return val;
}

incState() {
  return setState(getNextState());
}
